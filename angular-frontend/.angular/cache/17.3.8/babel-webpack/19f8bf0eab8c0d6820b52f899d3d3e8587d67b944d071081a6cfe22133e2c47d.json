{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { AttributeHashMap } from './HashMap';\n/**\n * Internal interface.\n *\n * Provides unique reporting for each collector. Allows synchronous collection\n * of metrics and reports given temporality values.\n */\nvar TemporalMetricProcessor = /** @class */function () {\n  function TemporalMetricProcessor(_aggregator, collectorHandles) {\n    var _this = this;\n    this._aggregator = _aggregator;\n    this._unreportedAccumulations = new Map();\n    this._reportHistory = new Map();\n    collectorHandles.forEach(function (handle) {\n      _this._unreportedAccumulations.set(handle, []);\n    });\n  }\n  /**\n   * Builds the {@link MetricData} streams to report against a specific MetricCollector.\n   * @param collector The information of the MetricCollector.\n   * @param collectors The registered collectors.\n   * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.\n   * @param currentAccumulations The current accumulation of metric data from instruments.\n   * @param collectionTime The current collection timestamp.\n   * @returns The {@link MetricData} points or `null`.\n   */\n  TemporalMetricProcessor.prototype.buildMetrics = function (collector, instrumentDescriptor, currentAccumulations, collectionTime) {\n    this._stashAccumulations(currentAccumulations);\n    var unreportedAccumulations = this._getMergedUnreportedAccumulations(collector);\n    var result = unreportedAccumulations;\n    var aggregationTemporality;\n    // Check our last report time.\n    if (this._reportHistory.has(collector)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      var last = this._reportHistory.get(collector);\n      var lastCollectionTime = last.collectionTime;\n      aggregationTemporality = last.aggregationTemporality;\n      // Use aggregation temporality + instrument to determine if we do a merge or a diff of\n      // previous. We have the following four scenarios:\n      // 1. Cumulative Aggregation (temporality) + Delta recording (sync instrument).\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 2. Cumulative Aggregation + Cumulative recording (async instrument).\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 3. Delta Aggregation + Delta recording\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n      // 4. Delta Aggregation + Cumulative recording.\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n      if (aggregationTemporality === AggregationTemporality.CUMULATIVE) {\n        // We need to make sure the current delta recording gets merged into the previous cumulative\n        // for the next cumulative recording.\n        result = TemporalMetricProcessor.merge(last.accumulations, unreportedAccumulations, this._aggregator);\n      } else {\n        result = TemporalMetricProcessor.calibrateStartTime(last.accumulations, unreportedAccumulations, lastCollectionTime);\n      }\n    } else {\n      // Call into user code to select aggregation temporality for the instrument.\n      aggregationTemporality = collector.selectAggregationTemporality(instrumentDescriptor.type);\n    }\n    // Update last reported (cumulative) accumulation.\n    this._reportHistory.set(collector, {\n      accumulations: result,\n      collectionTime: collectionTime,\n      aggregationTemporality: aggregationTemporality\n    });\n    var accumulationRecords = AttributesMapToAccumulationRecords(result);\n    // do not convert to metric data if there is nothing to convert.\n    if (accumulationRecords.length === 0) {\n      return undefined;\n    }\n    return this._aggregator.toMetricData(instrumentDescriptor, aggregationTemporality, accumulationRecords, /* endTime */collectionTime);\n  };\n  TemporalMetricProcessor.prototype._stashAccumulations = function (currentAccumulation) {\n    var e_1, _a;\n    var registeredCollectors = this._unreportedAccumulations.keys();\n    try {\n      for (var registeredCollectors_1 = __values(registeredCollectors), registeredCollectors_1_1 = registeredCollectors_1.next(); !registeredCollectors_1_1.done; registeredCollectors_1_1 = registeredCollectors_1.next()) {\n        var collector = registeredCollectors_1_1.value;\n        var stash = this._unreportedAccumulations.get(collector);\n        if (stash === undefined) {\n          stash = [];\n          this._unreportedAccumulations.set(collector, stash);\n        }\n        stash.push(currentAccumulation);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (registeredCollectors_1_1 && !registeredCollectors_1_1.done && (_a = registeredCollectors_1.return)) _a.call(registeredCollectors_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  TemporalMetricProcessor.prototype._getMergedUnreportedAccumulations = function (collector) {\n    var e_2, _a;\n    var result = new AttributeHashMap();\n    var unreportedList = this._unreportedAccumulations.get(collector);\n    this._unreportedAccumulations.set(collector, []);\n    if (unreportedList === undefined) {\n      return result;\n    }\n    try {\n      for (var unreportedList_1 = __values(unreportedList), unreportedList_1_1 = unreportedList_1.next(); !unreportedList_1_1.done; unreportedList_1_1 = unreportedList_1.next()) {\n        var it_1 = unreportedList_1_1.value;\n        result = TemporalMetricProcessor.merge(result, it_1, this._aggregator);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (unreportedList_1_1 && !unreportedList_1_1.done && (_a = unreportedList_1.return)) _a.call(unreportedList_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    return result;\n  };\n  TemporalMetricProcessor.merge = function (last, current, aggregator) {\n    var result = last;\n    var iterator = current.entries();\n    var next = iterator.next();\n    while (next.done !== true) {\n      var _a = __read(next.value, 3),\n        key = _a[0],\n        record = _a[1],\n        hash = _a[2];\n      if (last.has(key, hash)) {\n        var lastAccumulation = last.get(key, hash);\n        // last.has() returned true, lastAccumulation is present.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        var accumulation = aggregator.merge(lastAccumulation, record);\n        result.set(key, accumulation, hash);\n      } else {\n        result.set(key, record, hash);\n      }\n      next = iterator.next();\n    }\n    return result;\n  };\n  /**\n   * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves\n   * the new stream to be the initial observation time unchanged.\n   */\n  TemporalMetricProcessor.calibrateStartTime = function (last, current, lastCollectionTime) {\n    var e_3, _a;\n    try {\n      for (var _b = __values(last.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = __read(_c.value, 2),\n          key = _d[0],\n          hash = _d[1];\n        var currentAccumulation = current.get(key, hash);\n        currentAccumulation === null || currentAccumulation === void 0 ? void 0 : currentAccumulation.setStartTime(lastCollectionTime);\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n    return current;\n  };\n  return TemporalMetricProcessor;\n}();\nexport { TemporalMetricProcessor };\n// TypeScript complains about converting 3 elements tuple to AccumulationRecord<T>.\nfunction AttributesMapToAccumulationRecords(map) {\n  return Array.from(map.entries());\n}\n//# sourceMappingURL=TemporalMetricProcessor.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}