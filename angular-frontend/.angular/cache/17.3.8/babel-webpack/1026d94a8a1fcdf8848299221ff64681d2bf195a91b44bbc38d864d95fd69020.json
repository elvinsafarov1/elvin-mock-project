{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { context, diag, propagation, trace } from '@opentelemetry/api';\nimport { CompositePropagator, W3CBaggagePropagator, W3CTraceContextPropagator, getEnv, merge } from '@opentelemetry/core';\nimport { Resource } from '@opentelemetry/resources';\nimport { Tracer } from './Tracer';\nimport { loadDefaultConfig } from './config';\nimport { MultiSpanProcessor } from './MultiSpanProcessor';\nimport { NoopSpanProcessor } from './export/NoopSpanProcessor';\nimport { BatchSpanProcessor } from './platform';\nimport { reconfigureLimits } from './utility';\nexport var ForceFlushState = /*#__PURE__*/function (ForceFlushState) {\n  ForceFlushState[ForceFlushState[\"resolved\"] = 0] = \"resolved\";\n  ForceFlushState[ForceFlushState[\"timeout\"] = 1] = \"timeout\";\n  ForceFlushState[ForceFlushState[\"error\"] = 2] = \"error\";\n  ForceFlushState[ForceFlushState[\"unresolved\"] = 3] = \"unresolved\";\n  return ForceFlushState;\n}(ForceFlushState || {});\n/**\n * This class represents a basic tracer provider which platform libraries can extend\n */\nvar BasicTracerProvider = /** @class */function () {\n  function BasicTracerProvider(config) {\n    if (config === void 0) {\n      config = {};\n    }\n    var _a, _b;\n    this._registeredSpanProcessors = [];\n    this._tracers = new Map();\n    var mergedConfig = merge({}, loadDefaultConfig(), reconfigureLimits(config));\n    this.resource = (_a = mergedConfig.resource) !== null && _a !== void 0 ? _a : Resource.empty();\n    if (mergedConfig.mergeResourceWithDefaults) {\n      this.resource = Resource.default().merge(this.resource);\n    }\n    this._config = Object.assign({}, mergedConfig, {\n      resource: this.resource\n    });\n    if ((_b = config.spanProcessors) === null || _b === void 0 ? void 0 : _b.length) {\n      this._registeredSpanProcessors = __spreadArray([], __read(config.spanProcessors), false);\n      this.activeSpanProcessor = new MultiSpanProcessor(this._registeredSpanProcessors);\n    } else {\n      var defaultExporter = this._buildExporterFromEnv();\n      if (defaultExporter !== undefined) {\n        var batchProcessor = new BatchSpanProcessor(defaultExporter);\n        this.activeSpanProcessor = batchProcessor;\n      } else {\n        this.activeSpanProcessor = new NoopSpanProcessor();\n      }\n    }\n  }\n  BasicTracerProvider.prototype.getTracer = function (name, version, options) {\n    var key = name + \"@\" + (version || '') + \":\" + ((options === null || options === void 0 ? void 0 : options.schemaUrl) || '');\n    if (!this._tracers.has(key)) {\n      this._tracers.set(key, new Tracer({\n        name: name,\n        version: version,\n        schemaUrl: options === null || options === void 0 ? void 0 : options.schemaUrl\n      }, this._config, this));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this._tracers.get(key);\n  };\n  /**\n   * @deprecated please use {@link TracerConfig} spanProcessors property\n   * Adds a new {@link SpanProcessor} to this tracer.\n   * @param spanProcessor the new SpanProcessor to be added.\n   */\n  BasicTracerProvider.prototype.addSpanProcessor = function (spanProcessor) {\n    if (this._registeredSpanProcessors.length === 0) {\n      // since we might have enabled by default a batchProcessor, we disable it\n      // before adding the new one\n      this.activeSpanProcessor.shutdown().catch(function (err) {\n        return diag.error('Error while trying to shutdown current span processor', err);\n      });\n    }\n    this._registeredSpanProcessors.push(spanProcessor);\n    this.activeSpanProcessor = new MultiSpanProcessor(this._registeredSpanProcessors);\n  };\n  BasicTracerProvider.prototype.getActiveSpanProcessor = function () {\n    return this.activeSpanProcessor;\n  };\n  /**\n   * Register this TracerProvider for use with the OpenTelemetry API.\n   * Undefined values may be replaced with defaults, and\n   * null values will be skipped.\n   *\n   * @param config Configuration object for SDK registration\n   */\n  BasicTracerProvider.prototype.register = function (config) {\n    if (config === void 0) {\n      config = {};\n    }\n    trace.setGlobalTracerProvider(this);\n    if (config.propagator === undefined) {\n      config.propagator = this._buildPropagatorFromEnv();\n    }\n    if (config.contextManager) {\n      context.setGlobalContextManager(config.contextManager);\n    }\n    if (config.propagator) {\n      propagation.setGlobalPropagator(config.propagator);\n    }\n  };\n  BasicTracerProvider.prototype.forceFlush = function () {\n    var timeout = this._config.forceFlushTimeoutMillis;\n    var promises = this._registeredSpanProcessors.map(function (spanProcessor) {\n      return new Promise(function (resolve) {\n        var state;\n        var timeoutInterval = setTimeout(function () {\n          resolve(new Error(\"Span processor did not completed within timeout period of \" + timeout + \" ms\"));\n          state = ForceFlushState.timeout;\n        }, timeout);\n        spanProcessor.forceFlush().then(function () {\n          clearTimeout(timeoutInterval);\n          if (state !== ForceFlushState.timeout) {\n            state = ForceFlushState.resolved;\n            resolve(state);\n          }\n        }).catch(function (error) {\n          clearTimeout(timeoutInterval);\n          state = ForceFlushState.error;\n          resolve(error);\n        });\n      });\n    });\n    return new Promise(function (resolve, reject) {\n      Promise.all(promises).then(function (results) {\n        var errors = results.filter(function (result) {\n          return result !== ForceFlushState.resolved;\n        });\n        if (errors.length > 0) {\n          reject(errors);\n        } else {\n          resolve();\n        }\n      }).catch(function (error) {\n        return reject([error]);\n      });\n    });\n  };\n  BasicTracerProvider.prototype.shutdown = function () {\n    return this.activeSpanProcessor.shutdown();\n  };\n  /**\n   * TS cannot yet infer the type of this.constructor:\n   * https://github.com/Microsoft/TypeScript/issues/3841#issuecomment-337560146\n   * There is no need to override either of the getters in your child class.\n   * The type of the registered component maps should be the same across all\n   * classes in the inheritance tree.\n   */\n  BasicTracerProvider.prototype._getPropagator = function (name) {\n    var _a;\n    return (_a = this.constructor._registeredPropagators.get(name)) === null || _a === void 0 ? void 0 : _a();\n  };\n  BasicTracerProvider.prototype._getSpanExporter = function (name) {\n    var _a;\n    return (_a = this.constructor._registeredExporters.get(name)) === null || _a === void 0 ? void 0 : _a();\n  };\n  BasicTracerProvider.prototype._buildPropagatorFromEnv = function () {\n    var _this = this;\n    // per spec, propagators from env must be deduplicated\n    var uniquePropagatorNames = Array.from(new Set(getEnv().OTEL_PROPAGATORS));\n    var propagators = uniquePropagatorNames.map(function (name) {\n      var propagator = _this._getPropagator(name);\n      if (!propagator) {\n        diag.warn(\"Propagator \\\"\" + name + \"\\\" requested through environment variable is unavailable.\");\n      }\n      return propagator;\n    });\n    var validPropagators = propagators.reduce(function (list, item) {\n      if (item) {\n        list.push(item);\n      }\n      return list;\n    }, []);\n    if (validPropagators.length === 0) {\n      return;\n    } else if (uniquePropagatorNames.length === 1) {\n      return validPropagators[0];\n    } else {\n      return new CompositePropagator({\n        propagators: validPropagators\n      });\n    }\n  };\n  BasicTracerProvider.prototype._buildExporterFromEnv = function () {\n    var exporterName = getEnv().OTEL_TRACES_EXPORTER;\n    if (exporterName === 'none' || exporterName === '') return;\n    var exporter = this._getSpanExporter(exporterName);\n    if (!exporter) {\n      diag.error(\"Exporter \\\"\" + exporterName + \"\\\" requested through environment variable is unavailable.\");\n    }\n    return exporter;\n  };\n  BasicTracerProvider._registeredPropagators = new Map([['tracecontext', function () {\n    return new W3CTraceContextPropagator();\n  }], ['baggage', function () {\n    return new W3CBaggagePropagator();\n  }]]);\n  BasicTracerProvider._registeredExporters = new Map();\n  return BasicTracerProvider;\n}();\nexport { BasicTracerProvider };\n//# sourceMappingURL=BasicTracerProvider.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}