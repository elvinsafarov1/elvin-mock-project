{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { AggregatorKind } from './types';\nimport { DataPointType } from '../export/MetricData';\nimport { diag } from '@opentelemetry/api';\nimport { InstrumentType } from '../InstrumentDescriptor';\nimport { Buckets } from './exponential-histogram/Buckets';\nimport { getMapping } from './exponential-histogram/mapping/getMapping';\nimport { nextGreaterSquare } from './exponential-histogram/util';\n// HighLow is a utility class used for computing a common scale for\n// two exponential histogram accumulations\nvar HighLow = /** @class */function () {\n  function HighLow(low, high) {\n    this.low = low;\n    this.high = high;\n  }\n  HighLow.combine = function (h1, h2) {\n    return new HighLow(Math.min(h1.low, h2.low), Math.max(h1.high, h2.high));\n  };\n  return HighLow;\n}();\nvar MAX_SCALE = 20;\nvar DEFAULT_MAX_SIZE = 160;\nvar MIN_MAX_SIZE = 2;\nvar ExponentialHistogramAccumulation = /** @class */function () {\n  function ExponentialHistogramAccumulation(startTime, _maxSize, _recordMinMax, _sum, _count, _zeroCount, _min, _max, _positive, _negative, _mapping) {\n    if (startTime === void 0) {\n      startTime = startTime;\n    }\n    if (_maxSize === void 0) {\n      _maxSize = DEFAULT_MAX_SIZE;\n    }\n    if (_recordMinMax === void 0) {\n      _recordMinMax = true;\n    }\n    if (_sum === void 0) {\n      _sum = 0;\n    }\n    if (_count === void 0) {\n      _count = 0;\n    }\n    if (_zeroCount === void 0) {\n      _zeroCount = 0;\n    }\n    if (_min === void 0) {\n      _min = Number.POSITIVE_INFINITY;\n    }\n    if (_max === void 0) {\n      _max = Number.NEGATIVE_INFINITY;\n    }\n    if (_positive === void 0) {\n      _positive = new Buckets();\n    }\n    if (_negative === void 0) {\n      _negative = new Buckets();\n    }\n    if (_mapping === void 0) {\n      _mapping = getMapping(MAX_SCALE);\n    }\n    this.startTime = startTime;\n    this._maxSize = _maxSize;\n    this._recordMinMax = _recordMinMax;\n    this._sum = _sum;\n    this._count = _count;\n    this._zeroCount = _zeroCount;\n    this._min = _min;\n    this._max = _max;\n    this._positive = _positive;\n    this._negative = _negative;\n    this._mapping = _mapping;\n    if (this._maxSize < MIN_MAX_SIZE) {\n      diag.warn(\"Exponential Histogram Max Size set to \" + this._maxSize + \",                 changing to the minimum size of: \" + MIN_MAX_SIZE);\n      this._maxSize = MIN_MAX_SIZE;\n    }\n  }\n  /**\n   * record updates a histogram with a single count\n   * @param {Number} value\n   */\n  ExponentialHistogramAccumulation.prototype.record = function (value) {\n    this.updateByIncrement(value, 1);\n  };\n  /**\n   * Sets the start time for this accumulation\n   * @param {HrTime} startTime\n   */\n  ExponentialHistogramAccumulation.prototype.setStartTime = function (startTime) {\n    this.startTime = startTime;\n  };\n  /**\n   * Returns the datapoint representation of this accumulation\n   * @param {HrTime} startTime\n   */\n  ExponentialHistogramAccumulation.prototype.toPointValue = function () {\n    return {\n      hasMinMax: this._recordMinMax,\n      min: this.min,\n      max: this.max,\n      sum: this.sum,\n      positive: {\n        offset: this.positive.offset,\n        bucketCounts: this.positive.counts()\n      },\n      negative: {\n        offset: this.negative.offset,\n        bucketCounts: this.negative.counts()\n      },\n      count: this.count,\n      scale: this.scale,\n      zeroCount: this.zeroCount\n    };\n  };\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"sum\", {\n    /**\n     * @returns {Number} The sum of values recorded by this accumulation\n     */\n    get: function () {\n      return this._sum;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"min\", {\n    /**\n     * @returns {Number} The minimum value recorded by this accumulation\n     */\n    get: function () {\n      return this._min;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"max\", {\n    /**\n     * @returns {Number} The maximum value recorded by this accumulation\n     */\n    get: function () {\n      return this._max;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"count\", {\n    /**\n     * @returns {Number} The count of values recorded by this accumulation\n     */\n    get: function () {\n      return this._count;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"zeroCount\", {\n    /**\n     * @returns {Number} The number of 0 values recorded by this accumulation\n     */\n    get: function () {\n      return this._zeroCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"scale\", {\n    /**\n     * @returns {Number} The scale used by thie accumulation\n     */\n    get: function () {\n      if (this._count === this._zeroCount) {\n        // all zeros! scale doesn't matter, use zero\n        return 0;\n      }\n      return this._mapping.scale;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"positive\", {\n    /**\n     * positive holds the postive values\n     * @returns {Buckets}\n     */\n    get: function () {\n      return this._positive;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"negative\", {\n    /**\n     * negative holds the negative values by their absolute value\n     * @returns {Buckets}\n     */\n    get: function () {\n      return this._negative;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * uppdateByIncr supports updating a histogram with a non-negative\n   * increment.\n   * @param value\n   * @param increment\n   */\n  ExponentialHistogramAccumulation.prototype.updateByIncrement = function (value, increment) {\n    if (value > this._max) {\n      this._max = value;\n    }\n    if (value < this._min) {\n      this._min = value;\n    }\n    this._count += increment;\n    if (value === 0) {\n      this._zeroCount += increment;\n      return;\n    }\n    this._sum += value * increment;\n    if (value > 0) {\n      this._updateBuckets(this._positive, value, increment);\n    } else {\n      this._updateBuckets(this._negative, -value, increment);\n    }\n  };\n  /**\n   * merge combines data from previous value into self\n   * @param {ExponentialHistogramAccumulation} previous\n   */\n  ExponentialHistogramAccumulation.prototype.merge = function (previous) {\n    if (this._count === 0) {\n      this._min = previous.min;\n      this._max = previous.max;\n    } else if (previous.count !== 0) {\n      if (previous.min < this.min) {\n        this._min = previous.min;\n      }\n      if (previous.max > this.max) {\n        this._max = previous.max;\n      }\n    }\n    this.startTime = previous.startTime;\n    this._sum += previous.sum;\n    this._count += previous.count;\n    this._zeroCount += previous.zeroCount;\n    var minScale = this._minScale(previous);\n    this._downscale(this.scale - minScale);\n    this._mergeBuckets(this.positive, previous, previous.positive, minScale);\n    this._mergeBuckets(this.negative, previous, previous.negative, minScale);\n  };\n  /**\n   * diff substracts other from self\n   * @param {ExponentialHistogramAccumulation} other\n   */\n  ExponentialHistogramAccumulation.prototype.diff = function (other) {\n    this._min = Infinity;\n    this._max = -Infinity;\n    this._sum -= other.sum;\n    this._count -= other.count;\n    this._zeroCount -= other.zeroCount;\n    var minScale = this._minScale(other);\n    this._downscale(this.scale - minScale);\n    this._diffBuckets(this.positive, other, other.positive, minScale);\n    this._diffBuckets(this.negative, other, other.negative, minScale);\n  };\n  /**\n   * clone returns a deep copy of self\n   * @returns {ExponentialHistogramAccumulation}\n   */\n  ExponentialHistogramAccumulation.prototype.clone = function () {\n    return new ExponentialHistogramAccumulation(this.startTime, this._maxSize, this._recordMinMax, this._sum, this._count, this._zeroCount, this._min, this._max, this.positive.clone(), this.negative.clone(), this._mapping);\n  };\n  /**\n   * _updateBuckets maps the incoming value to a bucket index for the current\n   * scale. If the bucket index is outside of the range of the backing array,\n   * it will rescale the backing array and update the mapping for the new scale.\n   */\n  ExponentialHistogramAccumulation.prototype._updateBuckets = function (buckets, value, increment) {\n    var index = this._mapping.mapToIndex(value);\n    // rescale the mapping if needed\n    var rescalingNeeded = false;\n    var high = 0;\n    var low = 0;\n    if (buckets.length === 0) {\n      buckets.indexStart = index;\n      buckets.indexEnd = buckets.indexStart;\n      buckets.indexBase = buckets.indexStart;\n    } else if (index < buckets.indexStart && buckets.indexEnd - index >= this._maxSize) {\n      rescalingNeeded = true;\n      low = index;\n      high = buckets.indexEnd;\n    } else if (index > buckets.indexEnd && index - buckets.indexStart >= this._maxSize) {\n      rescalingNeeded = true;\n      low = buckets.indexStart;\n      high = index;\n    }\n    // rescale and compute index at new scale\n    if (rescalingNeeded) {\n      var change = this._changeScale(high, low);\n      this._downscale(change);\n      index = this._mapping.mapToIndex(value);\n    }\n    this._incrementIndexBy(buckets, index, increment);\n  };\n  /**\n   * _incrementIndexBy increments the count of the bucket specified by `index`.\n   * If the index is outside of the range [buckets.indexStart, buckets.indexEnd]\n   * the boundaries of the backing array will be adjusted and more buckets will\n   * be added if needed.\n   */\n  ExponentialHistogramAccumulation.prototype._incrementIndexBy = function (buckets, index, increment) {\n    if (increment === 0) {\n      // nothing to do for a zero increment, can happen during a merge operation\n      return;\n    }\n    if (index < buckets.indexStart) {\n      var span = buckets.indexEnd - index;\n      if (span >= buckets.backing.length) {\n        this._grow(buckets, span + 1);\n      }\n      buckets.indexStart = index;\n    } else if (index > buckets.indexEnd) {\n      var span = index - buckets.indexStart;\n      if (span >= buckets.backing.length) {\n        this._grow(buckets, span + 1);\n      }\n      buckets.indexEnd = index;\n    }\n    var bucketIndex = index - buckets.indexBase;\n    if (bucketIndex < 0) {\n      bucketIndex += buckets.backing.length;\n    }\n    buckets.incrementBucket(bucketIndex, increment);\n  };\n  /**\n   * grow resizes the backing array by doubling in size up to maxSize.\n   * This extends the array with a bunch of zeros and copies the\n   * existing counts to the same position.\n   */\n  ExponentialHistogramAccumulation.prototype._grow = function (buckets, needed) {\n    var size = buckets.backing.length;\n    var bias = buckets.indexBase - buckets.indexStart;\n    var oldPositiveLimit = size - bias;\n    var newSize = nextGreaterSquare(needed);\n    if (newSize > this._maxSize) {\n      newSize = this._maxSize;\n    }\n    var newPositiveLimit = newSize - bias;\n    buckets.backing.growTo(newSize, oldPositiveLimit, newPositiveLimit);\n  };\n  /**\n   * _changeScale computes how much downscaling is needed by shifting the\n   * high and low values until they are separated by no more than size.\n   */\n  ExponentialHistogramAccumulation.prototype._changeScale = function (high, low) {\n    var change = 0;\n    while (high - low >= this._maxSize) {\n      high >>= 1;\n      low >>= 1;\n      change++;\n    }\n    return change;\n  };\n  /**\n   * _downscale subtracts `change` from the current mapping scale.\n   */\n  ExponentialHistogramAccumulation.prototype._downscale = function (change) {\n    if (change === 0) {\n      return;\n    }\n    if (change < 0) {\n      // Note: this should be impossible. If we get here it's because\n      // there is a bug in the implementation.\n      throw new Error(\"impossible change of scale: \" + this.scale);\n    }\n    var newScale = this._mapping.scale - change;\n    this._positive.downscale(change);\n    this._negative.downscale(change);\n    this._mapping = getMapping(newScale);\n  };\n  /**\n   * _minScale is used by diff and merge to compute an ideal combined scale\n   */\n  ExponentialHistogramAccumulation.prototype._minScale = function (other) {\n    var minScale = Math.min(this.scale, other.scale);\n    var highLowPos = HighLow.combine(this._highLowAtScale(this.positive, this.scale, minScale), this._highLowAtScale(other.positive, other.scale, minScale));\n    var highLowNeg = HighLow.combine(this._highLowAtScale(this.negative, this.scale, minScale), this._highLowAtScale(other.negative, other.scale, minScale));\n    return Math.min(minScale - this._changeScale(highLowPos.high, highLowPos.low), minScale - this._changeScale(highLowNeg.high, highLowNeg.low));\n  };\n  /**\n   * _highLowAtScale is used by diff and merge to compute an ideal combined scale.\n   */\n  ExponentialHistogramAccumulation.prototype._highLowAtScale = function (buckets, currentScale, newScale) {\n    if (buckets.length === 0) {\n      return new HighLow(0, -1);\n    }\n    var shift = currentScale - newScale;\n    return new HighLow(buckets.indexStart >> shift, buckets.indexEnd >> shift);\n  };\n  /**\n   * _mergeBuckets translates index values from another histogram and\n   * adds the values into the corresponding buckets of this histogram.\n   */\n  ExponentialHistogramAccumulation.prototype._mergeBuckets = function (ours, other, theirs, scale) {\n    var theirOffset = theirs.offset;\n    var theirChange = other.scale - scale;\n    for (var i = 0; i < theirs.length; i++) {\n      this._incrementIndexBy(ours, theirOffset + i >> theirChange, theirs.at(i));\n    }\n  };\n  /**\n   * _diffBuckets translates index values from another histogram and\n   * subtracts the values in the corresponding buckets of this histogram.\n   */\n  ExponentialHistogramAccumulation.prototype._diffBuckets = function (ours, other, theirs, scale) {\n    var theirOffset = theirs.offset;\n    var theirChange = other.scale - scale;\n    for (var i = 0; i < theirs.length; i++) {\n      var ourIndex = theirOffset + i >> theirChange;\n      var bucketIndex = ourIndex - ours.indexBase;\n      if (bucketIndex < 0) {\n        bucketIndex += ours.backing.length;\n      }\n      ours.decrementBucket(bucketIndex, theirs.at(i));\n    }\n    ours.trim();\n  };\n  return ExponentialHistogramAccumulation;\n}();\nexport { ExponentialHistogramAccumulation };\n/**\n * Aggregator for ExponentialHistogramAccumlations\n */\nvar ExponentialHistogramAggregator = /** @class */function () {\n  /**\n   * @param _maxSize Maximum number of buckets for each of the positive\n   *    and negative ranges, exclusive of the zero-bucket.\n   * @param _recordMinMax If set to true, min and max will be recorded.\n   *    Otherwise, min and max will not be recorded.\n   */\n  function ExponentialHistogramAggregator(_maxSize, _recordMinMax) {\n    this._maxSize = _maxSize;\n    this._recordMinMax = _recordMinMax;\n    this.kind = AggregatorKind.EXPONENTIAL_HISTOGRAM;\n  }\n  ExponentialHistogramAggregator.prototype.createAccumulation = function (startTime) {\n    return new ExponentialHistogramAccumulation(startTime, this._maxSize, this._recordMinMax);\n  };\n  /**\n   * Return the result of the merge of two exponential histogram accumulations.\n   */\n  ExponentialHistogramAggregator.prototype.merge = function (previous, delta) {\n    var result = delta.clone();\n    result.merge(previous);\n    return result;\n  };\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  ExponentialHistogramAggregator.prototype.diff = function (previous, current) {\n    var result = current.clone();\n    result.diff(previous);\n    return result;\n  };\n  ExponentialHistogramAggregator.prototype.toMetricData = function (descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n    return {\n      descriptor: descriptor,\n      aggregationTemporality: aggregationTemporality,\n      dataPointType: DataPointType.EXPONENTIAL_HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(function (_a) {\n        var _b = __read(_a, 2),\n          attributes = _b[0],\n          accumulation = _b[1];\n        var pointValue = accumulation.toPointValue();\n        // determine if instrument allows negative values.\n        var allowsNegativeValues = descriptor.type === InstrumentType.UP_DOWN_COUNTER || descriptor.type === InstrumentType.OBSERVABLE_GAUGE || descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n        return {\n          attributes: attributes,\n          startTime: accumulation.startTime,\n          endTime: endTime,\n          value: {\n            min: pointValue.hasMinMax ? pointValue.min : undefined,\n            max: pointValue.hasMinMax ? pointValue.max : undefined,\n            sum: !allowsNegativeValues ? pointValue.sum : undefined,\n            positive: {\n              offset: pointValue.positive.offset,\n              bucketCounts: pointValue.positive.bucketCounts\n            },\n            negative: {\n              offset: pointValue.negative.offset,\n              bucketCounts: pointValue.negative.bucketCounts\n            },\n            count: pointValue.count,\n            scale: pointValue.scale,\n            zeroCount: pointValue.zeroCount\n          }\n        };\n      })\n    };\n  };\n  return ExponentialHistogramAggregator;\n}();\nexport { ExponentialHistogramAggregator };\n//# sourceMappingURL=ExponentialHistogram.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}