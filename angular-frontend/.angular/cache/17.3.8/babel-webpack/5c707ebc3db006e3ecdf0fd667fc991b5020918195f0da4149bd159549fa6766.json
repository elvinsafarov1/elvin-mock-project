{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as api from '@opentelemetry/api';\nimport { sanitizeAttributes, isTracingSuppressed } from '@opentelemetry/core';\nimport { Span } from './Span';\nimport { mergeConfig } from './utility';\nimport { RandomIdGenerator } from './platform';\n/**\n * This class represents a basic tracer.\n */\nvar Tracer = /** @class */function () {\n  /**\n   * Constructs a new Tracer instance.\n   */\n  function Tracer(instrumentationLibrary, config, _tracerProvider) {\n    this._tracerProvider = _tracerProvider;\n    var localConfig = mergeConfig(config);\n    this._sampler = localConfig.sampler;\n    this._generalLimits = localConfig.generalLimits;\n    this._spanLimits = localConfig.spanLimits;\n    this._idGenerator = config.idGenerator || new RandomIdGenerator();\n    this.resource = _tracerProvider.resource;\n    this.instrumentationLibrary = instrumentationLibrary;\n  }\n  /**\n   * Starts a new Span or returns the default NoopSpan based on the sampling\n   * decision.\n   */\n  Tracer.prototype.startSpan = function (name, options, context) {\n    var _a, _b, _c;\n    if (options === void 0) {\n      options = {};\n    }\n    if (context === void 0) {\n      context = api.context.active();\n    }\n    // remove span from context in case a root span is requested via options\n    if (options.root) {\n      context = api.trace.deleteSpan(context);\n    }\n    var parentSpan = api.trace.getSpan(context);\n    if (isTracingSuppressed(context)) {\n      api.diag.debug('Instrumentation suppressed, returning Noop Span');\n      var nonRecordingSpan = api.trace.wrapSpanContext(api.INVALID_SPAN_CONTEXT);\n      return nonRecordingSpan;\n    }\n    var parentSpanContext = parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.spanContext();\n    var spanId = this._idGenerator.generateSpanId();\n    var traceId;\n    var traceState;\n    var parentSpanId;\n    if (!parentSpanContext || !api.trace.isSpanContextValid(parentSpanContext)) {\n      // New root span.\n      traceId = this._idGenerator.generateTraceId();\n    } else {\n      // New child span.\n      traceId = parentSpanContext.traceId;\n      traceState = parentSpanContext.traceState;\n      parentSpanId = parentSpanContext.spanId;\n    }\n    var spanKind = (_a = options.kind) !== null && _a !== void 0 ? _a : api.SpanKind.INTERNAL;\n    var links = ((_b = options.links) !== null && _b !== void 0 ? _b : []).map(function (link) {\n      return {\n        context: link.context,\n        attributes: sanitizeAttributes(link.attributes)\n      };\n    });\n    var attributes = sanitizeAttributes(options.attributes);\n    // make sampling decision\n    var samplingResult = this._sampler.shouldSample(context, traceId, name, spanKind, attributes, links);\n    traceState = (_c = samplingResult.traceState) !== null && _c !== void 0 ? _c : traceState;\n    var traceFlags = samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE;\n    var spanContext = {\n      traceId: traceId,\n      spanId: spanId,\n      traceFlags: traceFlags,\n      traceState: traceState\n    };\n    if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {\n      api.diag.debug('Recording is off, propagating context in a non-recording span');\n      var nonRecordingSpan = api.trace.wrapSpanContext(spanContext);\n      return nonRecordingSpan;\n    }\n    // Set initial span attributes. The attributes object may have been mutated\n    // by the sampler, so we sanitize the merged attributes before setting them.\n    var initAttributes = sanitizeAttributes(Object.assign(attributes, samplingResult.attributes));\n    var span = new Span(this, context, name, spanContext, spanKind, parentSpanId, links, options.startTime, undefined, initAttributes);\n    return span;\n  };\n  Tracer.prototype.startActiveSpan = function (name, arg2, arg3, arg4) {\n    var opts;\n    var ctx;\n    var fn;\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2;\n    } else if (arguments.length === 3) {\n      opts = arg2;\n      fn = arg3;\n    } else {\n      opts = arg2;\n      ctx = arg3;\n      fn = arg4;\n    }\n    var parentContext = ctx !== null && ctx !== void 0 ? ctx : api.context.active();\n    var span = this.startSpan(name, opts, parentContext);\n    var contextWithSpanSet = api.trace.setSpan(parentContext, span);\n    return api.context.with(contextWithSpanSet, fn, undefined, span);\n  };\n  /** Returns the active {@link GeneralLimits}. */\n  Tracer.prototype.getGeneralLimits = function () {\n    return this._generalLimits;\n  };\n  /** Returns the active {@link SpanLimits}. */\n  Tracer.prototype.getSpanLimits = function () {\n    return this._spanLimits;\n  };\n  Tracer.prototype.getActiveSpanProcessor = function () {\n    return this._tracerProvider.getActiveSpanProcessor();\n  };\n  return Tracer;\n}();\nexport { Tracer };\n//# sourceMappingURL=Tracer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}