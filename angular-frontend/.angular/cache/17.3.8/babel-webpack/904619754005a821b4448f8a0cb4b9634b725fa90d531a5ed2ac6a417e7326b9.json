{"ast":null,"code":"import { ValueType } from '@opentelemetry/api';\nimport { AggregationTemporality, DataPointType } from '@opentelemetry/sdk-metrics';\nimport { toAttributes } from '../common/internal';\nimport { getOtlpEncoder } from '../common';\nexport function toResourceMetrics(resourceMetrics, options) {\n  var encoder = getOtlpEncoder(options);\n  return {\n    resource: {\n      attributes: toAttributes(resourceMetrics.resource.attributes),\n      droppedAttributesCount: 0\n    },\n    schemaUrl: undefined,\n    scopeMetrics: toScopeMetrics(resourceMetrics.scopeMetrics, encoder)\n  };\n}\nexport function toScopeMetrics(scopeMetrics, encoder) {\n  return Array.from(scopeMetrics.map(function (metrics) {\n    return {\n      scope: {\n        name: metrics.scope.name,\n        version: metrics.scope.version\n      },\n      metrics: metrics.metrics.map(function (metricData) {\n        return toMetric(metricData, encoder);\n      }),\n      schemaUrl: metrics.scope.schemaUrl\n    };\n  }));\n}\nexport function toMetric(metricData, encoder) {\n  var out = {\n    name: metricData.descriptor.name,\n    description: metricData.descriptor.description,\n    unit: metricData.descriptor.unit\n  };\n  var aggregationTemporality = toAggregationTemporality(metricData.aggregationTemporality);\n  switch (metricData.dataPointType) {\n    case DataPointType.SUM:\n      out.sum = {\n        aggregationTemporality: aggregationTemporality,\n        isMonotonic: metricData.isMonotonic,\n        dataPoints: toSingularDataPoints(metricData, encoder)\n      };\n      break;\n    case DataPointType.GAUGE:\n      out.gauge = {\n        dataPoints: toSingularDataPoints(metricData, encoder)\n      };\n      break;\n    case DataPointType.HISTOGRAM:\n      out.histogram = {\n        aggregationTemporality: aggregationTemporality,\n        dataPoints: toHistogramDataPoints(metricData, encoder)\n      };\n      break;\n    case DataPointType.EXPONENTIAL_HISTOGRAM:\n      out.exponentialHistogram = {\n        aggregationTemporality: aggregationTemporality,\n        dataPoints: toExponentialHistogramDataPoints(metricData, encoder)\n      };\n      break;\n  }\n  return out;\n}\nfunction toSingularDataPoint(dataPoint, valueType, encoder) {\n  var out = {\n    attributes: toAttributes(dataPoint.attributes),\n    startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),\n    timeUnixNano: encoder.encodeHrTime(dataPoint.endTime)\n  };\n  switch (valueType) {\n    case ValueType.INT:\n      out.asInt = dataPoint.value;\n      break;\n    case ValueType.DOUBLE:\n      out.asDouble = dataPoint.value;\n      break;\n  }\n  return out;\n}\nfunction toSingularDataPoints(metricData, encoder) {\n  return metricData.dataPoints.map(function (dataPoint) {\n    return toSingularDataPoint(dataPoint, metricData.descriptor.valueType, encoder);\n  });\n}\nfunction toHistogramDataPoints(metricData, encoder) {\n  return metricData.dataPoints.map(function (dataPoint) {\n    var histogram = dataPoint.value;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      bucketCounts: histogram.buckets.counts,\n      explicitBounds: histogram.buckets.boundaries,\n      count: histogram.count,\n      sum: histogram.sum,\n      min: histogram.min,\n      max: histogram.max,\n      startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),\n      timeUnixNano: encoder.encodeHrTime(dataPoint.endTime)\n    };\n  });\n}\nfunction toExponentialHistogramDataPoints(metricData, encoder) {\n  return metricData.dataPoints.map(function (dataPoint) {\n    var histogram = dataPoint.value;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      count: histogram.count,\n      min: histogram.min,\n      max: histogram.max,\n      sum: histogram.sum,\n      positive: {\n        offset: histogram.positive.offset,\n        bucketCounts: histogram.positive.bucketCounts\n      },\n      negative: {\n        offset: histogram.negative.offset,\n        bucketCounts: histogram.negative.bucketCounts\n      },\n      scale: histogram.scale,\n      zeroCount: histogram.zeroCount,\n      startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),\n      timeUnixNano: encoder.encodeHrTime(dataPoint.endTime)\n    };\n  });\n}\nfunction toAggregationTemporality(temporality) {\n  switch (temporality) {\n    case AggregationTemporality.DELTA:\n      return 1 /* AGGREGATION_TEMPORALITY_DELTA */;\n    case AggregationTemporality.CUMULATIVE:\n      return 2 /* AGGREGATION_TEMPORALITY_CUMULATIVE */;\n  }\n}\n//# sourceMappingURL=internal.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}