{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as ieee754 from './ieee754';\nimport * as util from '../util';\nimport { MappingError } from './types';\n/**\n * ExponentMapping implements exponential mapping functions for\n * scales <=0. For scales > 0 LogarithmMapping should be used.\n */\nvar ExponentMapping = /** @class */function () {\n  function ExponentMapping(scale) {\n    this._shift = -scale;\n  }\n  /**\n   * Maps positive floating point values to indexes corresponding to scale\n   * @param value\n   * @returns {number} index for provided value at the current scale\n   */\n  ExponentMapping.prototype.mapToIndex = function (value) {\n    if (value < ieee754.MIN_VALUE) {\n      return this._minNormalLowerBoundaryIndex();\n    }\n    var exp = ieee754.getNormalBase2(value);\n    // In case the value is an exact power of two, compute a\n    // correction of -1. Note, we are using a custom _rightShift\n    // to accommodate a 52-bit argument, which the native bitwise\n    // operators do not support\n    var correction = this._rightShift(ieee754.getSignificand(value) - 1, ieee754.SIGNIFICAND_WIDTH);\n    return exp + correction >> this._shift;\n  };\n  /**\n   * Returns the lower bucket boundary for the given index for scale\n   *\n   * @param index\n   * @returns {number}\n   */\n  ExponentMapping.prototype.lowerBoundary = function (index) {\n    var minIndex = this._minNormalLowerBoundaryIndex();\n    if (index < minIndex) {\n      throw new MappingError(\"underflow: \" + index + \" is < minimum lower boundary: \" + minIndex);\n    }\n    var maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index > maxIndex) {\n      throw new MappingError(\"overflow: \" + index + \" is > maximum lower boundary: \" + maxIndex);\n    }\n    return util.ldexp(1, index << this._shift);\n  };\n  Object.defineProperty(ExponentMapping.prototype, \"scale\", {\n    /**\n     * The scale used by this mapping\n     * @returns {number}\n     */\n    get: function () {\n      if (this._shift === 0) {\n        return 0;\n      }\n      return -this._shift;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  ExponentMapping.prototype._minNormalLowerBoundaryIndex = function () {\n    var index = ieee754.MIN_NORMAL_EXPONENT >> this._shift;\n    if (this._shift < 2) {\n      index--;\n    }\n    return index;\n  };\n  ExponentMapping.prototype._maxNormalLowerBoundaryIndex = function () {\n    return ieee754.MAX_NORMAL_EXPONENT >> this._shift;\n  };\n  ExponentMapping.prototype._rightShift = function (value, shift) {\n    return Math.floor(value * Math.pow(2, -shift));\n  };\n  return ExponentMapping;\n}();\nexport { ExponentMapping };\n//# sourceMappingURL=ExponentMapping.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}