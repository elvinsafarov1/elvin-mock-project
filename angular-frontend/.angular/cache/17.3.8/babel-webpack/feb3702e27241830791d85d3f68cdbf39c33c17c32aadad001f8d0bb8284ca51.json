{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { diag, SpanStatusCode } from '@opentelemetry/api';\nimport { addHrTimes, millisToHrTime, getTimeOrigin, hrTime, hrTimeDuration, isAttributeValue, isTimeInput, isTimeInputHrTime, otperformance, sanitizeAttributes } from '@opentelemetry/core';\nimport { SEMATTRS_EXCEPTION_MESSAGE, SEMATTRS_EXCEPTION_STACKTRACE, SEMATTRS_EXCEPTION_TYPE } from '@opentelemetry/semantic-conventions';\nimport { ExceptionEventName } from './enums';\n/**\n * This class represents a span.\n */\nvar Span = /** @class */function () {\n  /**\n   * Constructs a new Span instance.\n   *\n   * @deprecated calling Span constructor directly is not supported. Please use tracer.startSpan.\n   * */\n  function Span(parentTracer, context, spanName, spanContext, kind, parentSpanId, links, startTime, _deprecatedClock,\n  // keeping this argument even though it is unused to ensure backwards compatibility\n  attributes) {\n    if (links === void 0) {\n      links = [];\n    }\n    this.attributes = {};\n    this.links = [];\n    this.events = [];\n    this._droppedAttributesCount = 0;\n    this._droppedEventsCount = 0;\n    this._droppedLinksCount = 0;\n    this.status = {\n      code: SpanStatusCode.UNSET\n    };\n    this.endTime = [0, 0];\n    this._ended = false;\n    this._duration = [-1, -1];\n    this.name = spanName;\n    this._spanContext = spanContext;\n    this.parentSpanId = parentSpanId;\n    this.kind = kind;\n    this.links = links;\n    var now = Date.now();\n    this._performanceStartTime = otperformance.now();\n    this._performanceOffset = now - (this._performanceStartTime + getTimeOrigin());\n    this._startTimeProvided = startTime != null;\n    this.startTime = this._getTime(startTime !== null && startTime !== void 0 ? startTime : now);\n    this.resource = parentTracer.resource;\n    this.instrumentationLibrary = parentTracer.instrumentationLibrary;\n    this._spanLimits = parentTracer.getSpanLimits();\n    this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;\n    if (attributes != null) {\n      this.setAttributes(attributes);\n    }\n    this._spanProcessor = parentTracer.getActiveSpanProcessor();\n    this._spanProcessor.onStart(this, context);\n  }\n  Span.prototype.spanContext = function () {\n    return this._spanContext;\n  };\n  Span.prototype.setAttribute = function (key, value) {\n    if (value == null || this._isSpanEnded()) return this;\n    if (key.length === 0) {\n      diag.warn(\"Invalid attribute key: \" + key);\n      return this;\n    }\n    if (!isAttributeValue(value)) {\n      diag.warn(\"Invalid attribute value set for key: \" + key);\n      return this;\n    }\n    if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {\n      this._droppedAttributesCount++;\n      return this;\n    }\n    this.attributes[key] = this._truncateToSize(value);\n    return this;\n  };\n  Span.prototype.setAttributes = function (attributes) {\n    var e_1, _a;\n    try {\n      for (var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = __read(_c.value, 2),\n          k = _d[0],\n          v = _d[1];\n        this.setAttribute(k, v);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return this;\n  };\n  /**\n   *\n   * @param name Span Name\n   * @param [attributesOrStartTime] Span attributes or start time\n   *     if type is {@type TimeInput} and 3rd param is undefined\n   * @param [timeStamp] Specified time stamp for the event\n   */\n  Span.prototype.addEvent = function (name, attributesOrStartTime, timeStamp) {\n    if (this._isSpanEnded()) return this;\n    if (this._spanLimits.eventCountLimit === 0) {\n      diag.warn('No events allowed.');\n      this._droppedEventsCount++;\n      return this;\n    }\n    if (this.events.length >= this._spanLimits.eventCountLimit) {\n      if (this._droppedEventsCount === 0) {\n        diag.debug('Dropping extra events.');\n      }\n      this.events.shift();\n      this._droppedEventsCount++;\n    }\n    if (isTimeInput(attributesOrStartTime)) {\n      if (!isTimeInput(timeStamp)) {\n        timeStamp = attributesOrStartTime;\n      }\n      attributesOrStartTime = undefined;\n    }\n    var attributes = sanitizeAttributes(attributesOrStartTime);\n    this.events.push({\n      name: name,\n      attributes: attributes,\n      time: this._getTime(timeStamp),\n      droppedAttributesCount: 0\n    });\n    return this;\n  };\n  Span.prototype.addLink = function (link) {\n    this.links.push(link);\n    return this;\n  };\n  Span.prototype.addLinks = function (links) {\n    var _a;\n    (_a = this.links).push.apply(_a, __spreadArray([], __read(links), false));\n    return this;\n  };\n  Span.prototype.setStatus = function (status) {\n    if (this._isSpanEnded()) return this;\n    this.status = __assign({}, status);\n    // When using try-catch, the caught \"error\" is of type `any`. When then assigning `any` to `status.message`,\n    // TypeScript will not error. While this can happen during use of any API, it is more common on Span#setStatus()\n    // as it's likely used in a catch-block. Therefore, we validate if `status.message` is actually a string, null, or\n    // undefined to avoid an incorrect type causing issues downstream.\n    if (this.status.message != null && typeof status.message !== 'string') {\n      diag.warn(\"Dropping invalid status.message of type '\" + typeof status.message + \"', expected 'string'\");\n      delete this.status.message;\n    }\n    return this;\n  };\n  Span.prototype.updateName = function (name) {\n    if (this._isSpanEnded()) return this;\n    this.name = name;\n    return this;\n  };\n  Span.prototype.end = function (endTime) {\n    if (this._isSpanEnded()) {\n      diag.error(this.name + \" \" + this._spanContext.traceId + \"-\" + this._spanContext.spanId + \" - You can only call end() on a span once.\");\n      return;\n    }\n    this._ended = true;\n    this.endTime = this._getTime(endTime);\n    this._duration = hrTimeDuration(this.startTime, this.endTime);\n    if (this._duration[0] < 0) {\n      diag.warn('Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.', this.startTime, this.endTime);\n      this.endTime = this.startTime.slice();\n      this._duration = [0, 0];\n    }\n    if (this._droppedEventsCount > 0) {\n      diag.warn(\"Dropped \" + this._droppedEventsCount + \" events because eventCountLimit reached\");\n    }\n    this._spanProcessor.onEnd(this);\n  };\n  Span.prototype._getTime = function (inp) {\n    if (typeof inp === 'number' && inp <= otperformance.now()) {\n      // must be a performance timestamp\n      // apply correction and convert to hrtime\n      return hrTime(inp + this._performanceOffset);\n    }\n    if (typeof inp === 'number') {\n      return millisToHrTime(inp);\n    }\n    if (inp instanceof Date) {\n      return millisToHrTime(inp.getTime());\n    }\n    if (isTimeInputHrTime(inp)) {\n      return inp;\n    }\n    if (this._startTimeProvided) {\n      // if user provided a time for the start manually\n      // we can't use duration to calculate event/end times\n      return millisToHrTime(Date.now());\n    }\n    var msDuration = otperformance.now() - this._performanceStartTime;\n    return addHrTimes(this.startTime, millisToHrTime(msDuration));\n  };\n  Span.prototype.isRecording = function () {\n    return this._ended === false;\n  };\n  Span.prototype.recordException = function (exception, time) {\n    var attributes = {};\n    if (typeof exception === 'string') {\n      attributes[SEMATTRS_EXCEPTION_MESSAGE] = exception;\n    } else if (exception) {\n      if (exception.code) {\n        attributes[SEMATTRS_EXCEPTION_TYPE] = exception.code.toString();\n      } else if (exception.name) {\n        attributes[SEMATTRS_EXCEPTION_TYPE] = exception.name;\n      }\n      if (exception.message) {\n        attributes[SEMATTRS_EXCEPTION_MESSAGE] = exception.message;\n      }\n      if (exception.stack) {\n        attributes[SEMATTRS_EXCEPTION_STACKTRACE] = exception.stack;\n      }\n    }\n    // these are minimum requirements from spec\n    if (attributes[SEMATTRS_EXCEPTION_TYPE] || attributes[SEMATTRS_EXCEPTION_MESSAGE]) {\n      this.addEvent(ExceptionEventName, attributes, time);\n    } else {\n      diag.warn(\"Failed to record an exception \" + exception);\n    }\n  };\n  Object.defineProperty(Span.prototype, \"duration\", {\n    get: function () {\n      return this._duration;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Span.prototype, \"ended\", {\n    get: function () {\n      return this._ended;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Span.prototype, \"droppedAttributesCount\", {\n    get: function () {\n      return this._droppedAttributesCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Span.prototype, \"droppedEventsCount\", {\n    get: function () {\n      return this._droppedEventsCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Span.prototype, \"droppedLinksCount\", {\n    get: function () {\n      return this._droppedLinksCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Span.prototype._isSpanEnded = function () {\n    if (this._ended) {\n      diag.warn(\"Can not execute the operation on ended Span {traceId: \" + this._spanContext.traceId + \", spanId: \" + this._spanContext.spanId + \"}\");\n    }\n    return this._ended;\n  };\n  // Utility function to truncate given value within size\n  // for value type of string, will truncate to given limit\n  // for type of non-string, will return same value\n  Span.prototype._truncateToLimitUtil = function (value, limit) {\n    if (value.length <= limit) {\n      return value;\n    }\n    return value.substring(0, limit);\n  };\n  /**\n   * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then\n   * return string with truncated to {@code attributeValueLengthLimit} characters\n   *\n   * If the given attribute value is array of strings then\n   * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters\n   *\n   * Otherwise return same Attribute {@code value}\n   *\n   * @param value Attribute value\n   * @returns truncated attribute value if required, otherwise same value\n   */\n  Span.prototype._truncateToSize = function (value) {\n    var _this = this;\n    var limit = this._attributeValueLengthLimit;\n    // Check limit\n    if (limit <= 0) {\n      // Negative values are invalid, so do not truncate\n      diag.warn(\"Attribute value limit must be positive, got \" + limit);\n      return value;\n    }\n    // String\n    if (typeof value === 'string') {\n      return this._truncateToLimitUtil(value, limit);\n    }\n    // Array of strings\n    if (Array.isArray(value)) {\n      return value.map(function (val) {\n        return typeof val === 'string' ? _this._truncateToLimitUtil(val, limit) : val;\n      });\n    }\n    // Other types, no need to apply value length limit\n    return value;\n  };\n  return Span;\n}();\nexport { Span };\n//# sourceMappingURL=Span.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}