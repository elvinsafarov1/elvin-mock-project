{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as ieee754 from './ieee754';\nimport * as util from '../util';\nimport { MappingError } from './types';\n/**\n * LogarithmMapping implements exponential mapping functions for scale > 0.\n * For scales <= 0 the exponent mapping should be used.\n */\nvar LogarithmMapping = /** @class */function () {\n  function LogarithmMapping(scale) {\n    this._scale = scale;\n    this._scaleFactor = util.ldexp(Math.LOG2E, scale);\n    this._inverseFactor = util.ldexp(Math.LN2, -scale);\n  }\n  /**\n   * Maps positive floating point values to indexes corresponding to scale\n   * @param value\n   * @returns {number} index for provided value at the current scale\n   */\n  LogarithmMapping.prototype.mapToIndex = function (value) {\n    if (value <= ieee754.MIN_VALUE) {\n      return this._minNormalLowerBoundaryIndex() - 1;\n    }\n    // exact power of two special case\n    if (ieee754.getSignificand(value) === 0) {\n      var exp = ieee754.getNormalBase2(value);\n      return (exp << this._scale) - 1;\n    }\n    // non-power of two cases. use Math.floor to round the scaled logarithm\n    var index = Math.floor(Math.log(value) * this._scaleFactor);\n    var maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index >= maxIndex) {\n      return maxIndex;\n    }\n    return index;\n  };\n  /**\n   * Returns the lower bucket boundary for the given index for scale\n   *\n   * @param index\n   * @returns {number}\n   */\n  LogarithmMapping.prototype.lowerBoundary = function (index) {\n    var maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index >= maxIndex) {\n      if (index === maxIndex) {\n        return 2 * Math.exp((index - (1 << this._scale)) / this._scaleFactor);\n      }\n      throw new MappingError(\"overflow: \" + index + \" is > maximum lower boundary: \" + maxIndex);\n    }\n    var minIndex = this._minNormalLowerBoundaryIndex();\n    if (index <= minIndex) {\n      if (index === minIndex) {\n        return ieee754.MIN_VALUE;\n      } else if (index === minIndex - 1) {\n        return Math.exp((index + (1 << this._scale)) / this._scaleFactor) / 2;\n      }\n      throw new MappingError(\"overflow: \" + index + \" is < minimum lower boundary: \" + minIndex);\n    }\n    return Math.exp(index * this._inverseFactor);\n  };\n  Object.defineProperty(LogarithmMapping.prototype, \"scale\", {\n    /**\n     * The scale used by this mapping\n     * @returns {number}\n     */\n    get: function () {\n      return this._scale;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  LogarithmMapping.prototype._minNormalLowerBoundaryIndex = function () {\n    return ieee754.MIN_NORMAL_EXPONENT << this._scale;\n  };\n  LogarithmMapping.prototype._maxNormalLowerBoundaryIndex = function () {\n    return (ieee754.MAX_NORMAL_EXPONENT + 1 << this._scale) - 1;\n  };\n  return LogarithmMapping;\n}();\nexport { LogarithmMapping };\n//# sourceMappingURL=LogarithmMapping.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}