{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Buckets = /** @class */function () {\n  /**\n   * The term index refers to the number of the exponential histogram bucket\n   * used to determine its boundaries. The lower boundary of a bucket is\n   * determined by base ** index and the upper boundary of a bucket is\n   * determined by base ** (index + 1). index values are signed to account\n   * for values less than or equal to 1.\n   *\n   * indexBase is the index of the 0th position in the\n   * backing array, i.e., backing[0] is the count\n   * in the bucket with index `indexBase`.\n   *\n   * indexStart is the smallest index value represented\n   * in the backing array.\n   *\n   * indexEnd is the largest index value represented in\n   * the backing array.\n   */\n  function Buckets(backing, indexBase, indexStart, indexEnd) {\n    if (backing === void 0) {\n      backing = new BucketsBacking();\n    }\n    if (indexBase === void 0) {\n      indexBase = 0;\n    }\n    if (indexStart === void 0) {\n      indexStart = 0;\n    }\n    if (indexEnd === void 0) {\n      indexEnd = 0;\n    }\n    this.backing = backing;\n    this.indexBase = indexBase;\n    this.indexStart = indexStart;\n    this.indexEnd = indexEnd;\n  }\n  Object.defineProperty(Buckets.prototype, \"offset\", {\n    /**\n     * Offset is the bucket index of the smallest entry in the counts array\n     * @returns {number}\n     */\n    get: function () {\n      return this.indexStart;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Buckets.prototype, \"length\", {\n    /**\n     * Buckets is a view into the backing array.\n     * @returns {number}\n     */\n    get: function () {\n      if (this.backing.length === 0) {\n        return 0;\n      }\n      if (this.indexEnd === this.indexStart && this.at(0) === 0) {\n        return 0;\n      }\n      return this.indexEnd - this.indexStart + 1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * An array of counts, where count[i] carries the count\n   * of the bucket at index (offset+i).  count[i] is the count of\n   * values greater than base^(offset+i) and less than or equal to\n   * base^(offset+i+1).\n   * @returns {number} The logical counts based on the backing array\n   */\n  Buckets.prototype.counts = function () {\n    var _this = this;\n    return Array.from({\n      length: this.length\n    }, function (_, i) {\n      return _this.at(i);\n    });\n  };\n  /**\n   * At returns the count of the bucket at a position in the logical\n   * array of counts.\n   * @param position\n   * @returns {number}\n   */\n  Buckets.prototype.at = function (position) {\n    var bias = this.indexBase - this.indexStart;\n    if (position < bias) {\n      position += this.backing.length;\n    }\n    position -= bias;\n    return this.backing.countAt(position);\n  };\n  /**\n   * incrementBucket increments the backing array index by `increment`\n   * @param bucketIndex\n   * @param increment\n   */\n  Buckets.prototype.incrementBucket = function (bucketIndex, increment) {\n    this.backing.increment(bucketIndex, increment);\n  };\n  /**\n   * decrementBucket decrements the backing array index by `decrement`\n   * if decrement is greater than the current value, it's set to 0.\n   * @param bucketIndex\n   * @param decrement\n   */\n  Buckets.prototype.decrementBucket = function (bucketIndex, decrement) {\n    this.backing.decrement(bucketIndex, decrement);\n  };\n  /**\n   * trim removes leading and / or trailing zero buckets (which can occur\n   * after diffing two histos) and rotates the backing array so that the\n   * smallest non-zero index is in the 0th position of the backing array\n   */\n  Buckets.prototype.trim = function () {\n    for (var i = 0; i < this.length; i++) {\n      if (this.at(i) !== 0) {\n        this.indexStart += i;\n        break;\n      } else if (i === this.length - 1) {\n        //the entire array is zeroed out\n        this.indexStart = this.indexEnd = this.indexBase = 0;\n        return;\n      }\n    }\n    for (var i = this.length - 1; i >= 0; i--) {\n      if (this.at(i) !== 0) {\n        this.indexEnd -= this.length - i - 1;\n        break;\n      }\n    }\n    this._rotate();\n  };\n  /**\n   * downscale first rotates, then collapses 2**`by`-to-1 buckets.\n   * @param by\n   */\n  Buckets.prototype.downscale = function (by) {\n    this._rotate();\n    var size = 1 + this.indexEnd - this.indexStart;\n    var each = 1 << by;\n    var inpos = 0;\n    var outpos = 0;\n    for (var pos = this.indexStart; pos <= this.indexEnd;) {\n      var mod = pos % each;\n      if (mod < 0) {\n        mod += each;\n      }\n      for (var i = mod; i < each && inpos < size; i++) {\n        this._relocateBucket(outpos, inpos);\n        inpos++;\n        pos++;\n      }\n      outpos++;\n    }\n    this.indexStart >>= by;\n    this.indexEnd >>= by;\n    this.indexBase = this.indexStart;\n  };\n  /**\n   * Clone returns a deep copy of Buckets\n   * @returns {Buckets}\n   */\n  Buckets.prototype.clone = function () {\n    return new Buckets(this.backing.clone(), this.indexBase, this.indexStart, this.indexEnd);\n  };\n  /**\n   * _rotate shifts the backing array contents so that indexStart ==\n   * indexBase to simplify the downscale logic.\n   */\n  Buckets.prototype._rotate = function () {\n    var bias = this.indexBase - this.indexStart;\n    if (bias === 0) {\n      return;\n    } else if (bias > 0) {\n      this.backing.reverse(0, this.backing.length);\n      this.backing.reverse(0, bias);\n      this.backing.reverse(bias, this.backing.length);\n    } else {\n      // negative bias, this can happen when diffing two histograms\n      this.backing.reverse(0, this.backing.length);\n      this.backing.reverse(0, this.backing.length + bias);\n    }\n    this.indexBase = this.indexStart;\n  };\n  /**\n   * _relocateBucket adds the count in counts[src] to counts[dest] and\n   * resets count[src] to zero.\n   */\n  Buckets.prototype._relocateBucket = function (dest, src) {\n    if (dest === src) {\n      return;\n    }\n    this.incrementBucket(dest, this.backing.emptyBucket(src));\n  };\n  return Buckets;\n}();\nexport { Buckets };\n/**\n * BucketsBacking holds the raw buckets and some utility methods to\n * manage them.\n */\nvar BucketsBacking = /** @class */function () {\n  function BucketsBacking(_counts) {\n    if (_counts === void 0) {\n      _counts = [0];\n    }\n    this._counts = _counts;\n  }\n  Object.defineProperty(BucketsBacking.prototype, \"length\", {\n    /**\n     * length returns the physical size of the backing array, which\n     * is >= buckets.length()\n     */\n    get: function () {\n      return this._counts.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * countAt returns the count in a specific bucket\n   */\n  BucketsBacking.prototype.countAt = function (pos) {\n    return this._counts[pos];\n  };\n  /**\n   * growTo grows a backing array and copies old entries\n   * into their correct new positions.\n   */\n  BucketsBacking.prototype.growTo = function (newSize, oldPositiveLimit, newPositiveLimit) {\n    var tmp = new Array(newSize).fill(0);\n    tmp.splice.apply(tmp, __spreadArray([newPositiveLimit, this._counts.length - oldPositiveLimit], __read(this._counts.slice(oldPositiveLimit)), false));\n    tmp.splice.apply(tmp, __spreadArray([0, oldPositiveLimit], __read(this._counts.slice(0, oldPositiveLimit)), false));\n    this._counts = tmp;\n  };\n  /**\n   * reverse the items in the backing array in the range [from, limit).\n   */\n  BucketsBacking.prototype.reverse = function (from, limit) {\n    var num = Math.floor((from + limit) / 2) - from;\n    for (var i = 0; i < num; i++) {\n      var tmp = this._counts[from + i];\n      this._counts[from + i] = this._counts[limit - i - 1];\n      this._counts[limit - i - 1] = tmp;\n    }\n  };\n  /**\n   * emptyBucket empties the count from a bucket, for\n   * moving into another.\n   */\n  BucketsBacking.prototype.emptyBucket = function (src) {\n    var tmp = this._counts[src];\n    this._counts[src] = 0;\n    return tmp;\n  };\n  /**\n   * increments a bucket by `increment`\n   */\n  BucketsBacking.prototype.increment = function (bucketIndex, increment) {\n    this._counts[bucketIndex] += increment;\n  };\n  /**\n   * decrements a bucket by `decrement`\n   */\n  BucketsBacking.prototype.decrement = function (bucketIndex, decrement) {\n    if (this._counts[bucketIndex] >= decrement) {\n      this._counts[bucketIndex] -= decrement;\n    } else {\n      // this should not happen, but we're being defensive against\n      // negative counts.\n      this._counts[bucketIndex] = 0;\n    }\n  };\n  /**\n   * clone returns a deep copy of BucketsBacking\n   */\n  BucketsBacking.prototype.clone = function () {\n    return new BucketsBacking(__spreadArray([], __read(this._counts), false));\n  };\n  return BucketsBacking;\n}();\n//# sourceMappingURL=Buckets.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}